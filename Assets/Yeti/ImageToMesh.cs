using UnityEngine;using System.Collections;// This class creates a static mesh based on the input image.  To use, call////		ImageToMesh.CreateMesh(Texture2D image, float minAlphaComponent)////	minAlpha defines//// Example usage://	//	public Texture2D image;//	public float minAlphaComponent = 0.1f;//	//	void Start()//	{		//		GetComponent<MeshFilter>().mesh = ImageToMesh.CreateMesh(image, minAlphaComponent);	//	}public class ImageToMesh{	/// <summary>	/// Creates mesh from the input image.  The mesh boundries are taken from transparent pixels in the image.	/// with the minimum cut-off transparency defined by minAlphaComponent.  The mesh texture coords map back 	/// to the original image.  	/// </summary>	/// <param name="image" type="Texture2D">The input texture image</param>	/// <param name="minAlphaComponent">The cut-off alpha below which mesh vertices will not be created.</param>	public static Mesh CreateMesh(Texture2D image, float minAlphaComponent)	{		Mesh mesh = new Mesh();					ImageToMesh itm = new ImageToMesh(image, minAlphaComponent);			mesh.vertices = itm.vertices;		mesh.uv = itm.uv;		mesh.triangles = itm.triangles;		mesh.normals = itm.normals;						mesh.Optimize();				return mesh;	}		ArrayList vertexArrayList;	ArrayList triangleArrayList;	ArrayList uvArrayList;	ArrayList normalArrayList;		Texture2D image;	float minAlphaComponent;	bool[,] mappedPoints;	public Vector3[] vertices { get { return (Vector3[])vertexArrayList.ToArray(typeof(Vector3)); } }	public Vector2[] uv { get { return (Vector2[])uvArrayList.ToArray(typeof(Vector2)); } }	public Vector3[] normals { get { return (Vector3[])normalArrayList.ToArray(typeof(Vector3)); } }	public int[] triangles { get { return (int[])triangleArrayList.ToArray(typeof(int)); } }	public ImageToMesh(Texture2D anImage, float minAlpha)	{		// Loops through the image pixels, getting contours and faces.  Create quads for each face and around each contour		// Texture coords map back to the original image.  				image = anImage;		minAlphaComponent = minAlpha;		mappedPoints = new bool[image.width,image.height];		vertexArrayList = new ArrayList();		triangleArrayList = new ArrayList();		uvArrayList = new ArrayList();		normalArrayList = new ArrayList();						int x, y;		for (x = 0; x < image.width; x++)		{			for (y = 0; y < image.height; y++)			{				if (!mappedPoints[x,y])				{					GetContinuousFace(x, y);				}			}		}			}		bool GetContinuousFace(int x, int y)	{		if (mappedPoints[x, y])			return false;		Color color = image.GetPixel(x, y);		if (color.a <= minAlphaComponent)			return false;				AddFaceQuad(x, y, vertexArrayList);		mappedPoints[x, y] = true;		// Check adjacent faces.  If there is no face adjacent this pixel is on the edge		// and we add a vertical quad		bool added;		if (x+1 < image.width)		{			added = GetContinuousFace(x+1, y);			if (!added && !mappedPoints[x+1,y]) 				AddEdgeQuad(x, y, 1, 0);		}		if (x-1 >= 0)		{			added = GetContinuousFace(x-1, y);			if (!added && !mappedPoints[x-1,y]) 				AddEdgeQuad(x, y, -1, 0);		}		if (y+1 < image.height)		{			added = GetContinuousFace(x, y+1);			if (!added && !mappedPoints[x,y+1]) 				AddEdgeQuad(x, y, 0, 1);		}		if (y-1 >= 0)		{			added = GetContinuousFace(x, y-1);			if (!added && !mappedPoints[x,y-1]) 				AddEdgeQuad(x, y, 0, -1);		}					return true;	}		void AddFaceQuad(int x, int y, ArrayList vertexArrayList)	{		vertexArrayList.Add(new Vector3(x - 0.5f, y - 0.5f, 0.5f));		vertexArrayList.Add(new Vector3(x - 0.5f, y + 0.5f, 0.5f));		vertexArrayList.Add(new Vector3(x + 0.5f, y + 0.5f, 0.5f));		vertexArrayList.Add(new Vector3(x + 0.5f, y - 0.5f, 0.5f));		uvArrayList.Add(new Vector2((x - 0.0f) / image.width, (y - 0.0f) / image.height));		uvArrayList.Add(new Vector2((x - 0.0f) / image.width, (y + 1.0f) / image.height));		uvArrayList.Add(new Vector2((x + 1.0f) / image.width, (y + 1.0f) / image.height));		uvArrayList.Add(new Vector2((x + 1.0f) / image.width, (y - 0.0f) / image.height));				normalArrayList.Add(Vector3.forward);		normalArrayList.Add(Vector3.forward);		normalArrayList.Add(Vector3.forward);		normalArrayList.Add(Vector3.forward);				triangleArrayList.Add(vertexArrayList.Count-2);		triangleArrayList.Add(vertexArrayList.Count-3);		triangleArrayList.Add(vertexArrayList.Count-4);		triangleArrayList.Add(vertexArrayList.Count-1);		triangleArrayList.Add(vertexArrayList.Count-2);		triangleArrayList.Add(vertexArrayList.Count-4);				// Add the back faces		vertexArrayList.Add(new Vector3(x - 0.5f, y - 0.5f, -0.5f));		vertexArrayList.Add(new Vector3(x - 0.5f, y + 0.5f, -0.5f));		vertexArrayList.Add(new Vector3(x + 0.5f, y + 0.5f, -0.5f));		vertexArrayList.Add(new Vector3(x + 0.5f, y - 0.5f, -0.5f));		uvArrayList.Add(new Vector2((x - 0.0f) / image.width, (y - 0.0f) / image.height));		uvArrayList.Add(new Vector2((x - 0.0f) / image.width, (y + 1.0f) / image.height));		uvArrayList.Add(new Vector2((x + 1.0f) / image.width, (y + 1.0f) / image.height));		uvArrayList.Add(new Vector2((x + 1.0f) / image.width, (y - 0.0f) / image.height));		normalArrayList.Add(-Vector3.forward);		normalArrayList.Add(-Vector3.forward);		normalArrayList.Add(-Vector3.forward);		normalArrayList.Add(-Vector3.forward);				triangleArrayList.Add(vertexArrayList.Count-4);		triangleArrayList.Add(vertexArrayList.Count-3);		triangleArrayList.Add(vertexArrayList.Count-2);		triangleArrayList.Add(vertexArrayList.Count-4);		triangleArrayList.Add(vertexArrayList.Count-2);		triangleArrayList.Add(vertexArrayList.Count-1);	}		void AddEdgeQuad(int x, int y, int x_direction, int y_direction)	{		Vector3 v1, v2, v3, v4;		Vector3 normal;		if (x_direction == 1)		{			v1 = new Vector3( 0.5f, -0.5f, -0.5f);			v2 = new Vector3( 0.5f, +0.5f, -0.5f);			v3 = new Vector3( 0.5f, +0.5f,  0.5f);			v4 = new Vector3( 0.5f, -0.5f,  0.5f);			normal = Vector3.left;		}		else if (x_direction == -1)		{			v1 = new Vector3(-0.5f,  0.5f, -0.5f);			v2 = new Vector3(-0.5f, -0.5f, -0.5f);			v3 = new Vector3(-0.5f, -0.5f,  0.5f);			v4 = new Vector3(-0.5f,  0.5f,  0.5f);			normal = -Vector3.left;		}		else if (y_direction == 1)		{			v1 = new Vector3(-0.5f,  0.5f,  0.5f);			v2 = new Vector3(+0.5f,  0.5f,  0.5f);			v3 = new Vector3(+0.5f,  0.5f, -0.5f);			v4 = new Vector3(-0.5f,  0.5f, -0.5f);			normal = Vector3.up;		}		else // y_direction == -1		{			v1 = new Vector3( 0.5f, -0.5f,  0.5f);			v2 = new Vector3(-0.5f, -0.5f,  0.5f);			v3 = new Vector3(-0.5f, -0.5f, -0.5f);			v4 = new Vector3( 0.5f, -0.5f, -0.5f);			normal = -Vector3.up;		}				vertexArrayList.Add(new Vector3(x, y, 0) + v1);		vertexArrayList.Add(new Vector3(x, y, 0) + v2);		vertexArrayList.Add(new Vector3(x, y, 0) + v3);		vertexArrayList.Add(new Vector3(x, y, 0) + v4);		uvArrayList.Add(new Vector2((x - 0.0f) / image.width, (y - 0.0f) / image.height));		uvArrayList.Add(new Vector2((x - 0.0f) / image.width, (y - 0.0f) / image.height));		uvArrayList.Add(new Vector2((x - 0.0f) / image.width, (y - 0.0f) / image.height));		uvArrayList.Add(new Vector2((x - 0.0f) / image.width, (y - 0.0f) / image.height));				normalArrayList.Add(normal);		normalArrayList.Add(normal);		normalArrayList.Add(normal);		normalArrayList.Add(normal);				triangleArrayList.Add(vertexArrayList.Count-4);		triangleArrayList.Add(vertexArrayList.Count-3);		triangleArrayList.Add(vertexArrayList.Count-2);		triangleArrayList.Add(vertexArrayList.Count-4);		triangleArrayList.Add(vertexArrayList.Count-2);		triangleArrayList.Add(vertexArrayList.Count-1);	}}